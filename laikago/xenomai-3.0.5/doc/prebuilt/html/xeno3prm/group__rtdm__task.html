<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xenomai: Task Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__rtdm__task.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Task Services<div class="ingroups"><a class="el" href="group__rtdm.html">RTDM</a> &raquo; <a class="el" href="group__rtdm__driver__interface.html">Driver programming interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Task Services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtdm__task.png" border="0" alt="" usemap="#group____rtdm____task"/>
<map name="group____rtdm____task" id="group____rtdm____task">
<area shape="rect" id="node1" href="group__rtdm__driver__interface.html" title="RTDM driver programming interface. " alt="" coords="5,5,141,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga43315f778f88bdd7415504c6f6d0e0af"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga43315f778f88bdd7415504c6f6d0e0af">rtdm_task_proc_t</a>) (void *arg)</td></tr>
<tr class="memdesc:ga43315f778f88bdd7415504c6f6d0e0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-time task procedure.  <a href="#ga43315f778f88bdd7415504c6f6d0e0af">More...</a><br /></td></tr>
<tr class="separator:ga43315f778f88bdd7415504c6f6d0e0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga44b0701b6c28fa8035711f800fdcd371"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init</a> (rtdm_task_t *task, const char *name, <a class="el" href="group__rtdm__task.html#ga43315f778f88bdd7415504c6f6d0e0af">rtdm_task_proc_t</a> task_proc, void *arg, int priority, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> period)</td></tr>
<tr class="memdesc:ga44b0701b6c28fa8035711f800fdcd371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise and start a real-time task.  <a href="#ga44b0701b6c28fa8035711f800fdcd371">More...</a><br /></td></tr>
<tr class="separator:ga44b0701b6c28fa8035711f800fdcd371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5581febb2732127736817ca44e86e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga7b5581febb2732127736817ca44e86e3">rtdm_task_destroy</a> (rtdm_task_t *task)</td></tr>
<tr class="memdesc:ga7b5581febb2732127736817ca44e86e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a real-time task.  <a href="#ga7b5581febb2732127736817ca44e86e3">More...</a><br /></td></tr>
<tr class="separator:ga7b5581febb2732127736817ca44e86e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118ff0961fe05db91c15af5f27bf48dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga118ff0961fe05db91c15af5f27bf48dc">rtdm_task_should_stop</a> (void)</td></tr>
<tr class="memdesc:ga118ff0961fe05db91c15af5f27bf48dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for pending termination request.  <a href="#ga118ff0961fe05db91c15af5f27bf48dc">More...</a><br /></td></tr>
<tr class="separator:ga118ff0961fe05db91c15af5f27bf48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286f2d3ff73b3e9c5f24d5a1122a57d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga286f2d3ff73b3e9c5f24d5a1122a57d2">rtdm_task_set_priority</a> (rtdm_task_t *task, int priority)</td></tr>
<tr class="memdesc:ga286f2d3ff73b3e9c5f24d5a1122a57d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust real-time task priority.  <a href="#ga286f2d3ff73b3e9c5f24d5a1122a57d2">More...</a><br /></td></tr>
<tr class="separator:ga286f2d3ff73b3e9c5f24d5a1122a57d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b950475e86d8201cc31724421e0857b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga4b950475e86d8201cc31724421e0857b">rtdm_task_set_period</a> (rtdm_task_t *task, <a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a> start_date, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> period)</td></tr>
<tr class="memdesc:ga4b950475e86d8201cc31724421e0857b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust real-time task period.  <a href="#ga4b950475e86d8201cc31724421e0857b">More...</a><br /></td></tr>
<tr class="separator:ga4b950475e86d8201cc31724421e0857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987d8dcff4e3ec43392d1fe18481639f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga987d8dcff4e3ec43392d1fe18481639f">rtdm_task_wait_period</a> (unsigned long *overruns_r)</td></tr>
<tr class="memdesc:ga987d8dcff4e3ec43392d1fe18481639f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on next real-time task period.  <a href="#ga987d8dcff4e3ec43392d1fe18481639f">More...</a><br /></td></tr>
<tr class="separator:ga987d8dcff4e3ec43392d1fe18481639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae52cca97ebaf78eec2e31553a4dacd5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e">rtdm_task_unblock</a> (rtdm_task_t *task)</td></tr>
<tr class="memdesc:gae52cca97ebaf78eec2e31553a4dacd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a blocked real-time task.  <a href="#gae52cca97ebaf78eec2e31553a4dacd5e">More...</a><br /></td></tr>
<tr class="separator:gae52cca97ebaf78eec2e31553a4dacd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd58b762de7269549d1e54699ceebc0d"><td class="memItemLeft" align="right" valign="top">rtdm_task_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#gafd58b762de7269549d1e54699ceebc0d">rtdm_task_current</a> (void)</td></tr>
<tr class="memdesc:gafd58b762de7269549d1e54699ceebc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current real-time task.  <a href="#gafd58b762de7269549d1e54699ceebc0d">More...</a><br /></td></tr>
<tr class="separator:gafd58b762de7269549d1e54699ceebc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfae53746165a83a75965b7b0f6710a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#gabfae53746165a83a75965b7b0f6710a0">rtdm_task_sleep</a> (<a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> delay)</td></tr>
<tr class="memdesc:gabfae53746165a83a75965b7b0f6710a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep a specified amount of time.  <a href="#gabfae53746165a83a75965b7b0f6710a0">More...</a><br /></td></tr>
<tr class="separator:gabfae53746165a83a75965b7b0f6710a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741998821c05483db33f17d77c733d99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga741998821c05483db33f17d77c733d99">rtdm_task_sleep_until</a> (<a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a> wakeup_time)</td></tr>
<tr class="memdesc:ga741998821c05483db33f17d77c733d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep until a specified absolute time.  <a href="#ga741998821c05483db33f17d77c733d99">More...</a><br /></td></tr>
<tr class="separator:ga741998821c05483db33f17d77c733d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1763346568d041f9c66d68224816d15b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga1763346568d041f9c66d68224816d15b">rtdm_task_sleep_abs</a> (<a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a> wakeup_time, enum <a class="el" href="group__rtdm__timer.html#gad0bffecd0182d68967ebb5b47df0bcd0">rtdm_timer_mode</a> mode)</td></tr>
<tr class="memdesc:ga1763346568d041f9c66d68224816d15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep until a specified absolute time.  <a href="#ga1763346568d041f9c66d68224816d15b">More...</a><br /></td></tr>
<tr class="separator:ga1763346568d041f9c66d68224816d15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa288d5cf336a98cace8b47eaacb4c629"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#gaa288d5cf336a98cace8b47eaacb4c629">rtdm_task_busy_wait</a> (bool condition, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> spin_ns, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> sleep_ns)</td></tr>
<tr class="memdesc:gaa288d5cf336a98cace8b47eaacb4c629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe busy waiting.  <a href="#gaa288d5cf336a98cace8b47eaacb4c629">More...</a><br /></td></tr>
<tr class="separator:gaa288d5cf336a98cace8b47eaacb4c629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87dd3ab9abed5417dfcc00f463fd86ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga87dd3ab9abed5417dfcc00f463fd86ec">rtdm_wait_prepare</a> (struct rtdm_wait_context *wc)</td></tr>
<tr class="memdesc:ga87dd3ab9abed5417dfcc00f463fd86ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register wait context.  <a href="#ga87dd3ab9abed5417dfcc00f463fd86ec">More...</a><br /></td></tr>
<tr class="separator:ga87dd3ab9abed5417dfcc00f463fd86ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c0a155cc11c7ef221262c8f9823005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga95c0a155cc11c7ef221262c8f9823005">rtdm_wait_complete</a> (struct rtdm_wait_context *wc)</td></tr>
<tr class="memdesc:ga95c0a155cc11c7ef221262c8f9823005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark completion for a wait context.  <a href="#ga95c0a155cc11c7ef221262c8f9823005">More...</a><br /></td></tr>
<tr class="separator:ga95c0a155cc11c7ef221262c8f9823005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc457f5ed51446d25d06f11e9d3b8c47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#gadc457f5ed51446d25d06f11e9d3b8c47">rtdm_wait_is_completed</a> (struct rtdm_wait_context *wc)</td></tr>
<tr class="memdesc:gadc457f5ed51446d25d06f11e9d3b8c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test completion of a wait context.  <a href="#gadc457f5ed51446d25d06f11e9d3b8c47">More...</a><br /></td></tr>
<tr class="separator:gadc457f5ed51446d25d06f11e9d3b8c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3e4c00605861403c0ea4ec87b31a7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#ga3a3e4c00605861403c0ea4ec87b31a7b">rtdm_task_join</a> (rtdm_task_t *task)</td></tr>
<tr class="memdesc:ga3a3e4c00605861403c0ea4ec87b31a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a real-time task to terminate.  <a href="#ga3a3e4c00605861403c0ea4ec87b31a7b">More...</a><br /></td></tr>
<tr class="separator:ga3a3e4c00605861403c0ea4ec87b31a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3940cfff7cc72d7bc064a3e279d74ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__task.html#gaa3940cfff7cc72d7bc064a3e279d74ac">rtdm_task_busy_sleep</a> (<a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> delay)</td></tr>
<tr class="memdesc:gaa3940cfff7cc72d7bc064a3e279d74ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy-wait a specified amount of time.  <a href="#gaa3940cfff7cc72d7bc064a3e279d74ac">More...</a><br /></td></tr>
<tr class="separator:gaa3940cfff7cc72d7bc064a3e279d74ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Task Priority Range</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7b76feb5dd60eb2fa4dedc6d1d7bb08e"></a><a class="anchor" id="rtdmtaskprio"></a>Maximum and minimum task priorities </p>
</td></tr>
<tr class="memitem:ga06f12fa27637f0a61906a02bbfd27c8c"><td class="memItemLeft" align="right" valign="top"><a id="ga06f12fa27637f0a61906a02bbfd27c8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTDM_TASK_LOWEST_PRIORITY</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga06f12fa27637f0a61906a02bbfd27c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b4e739fd61aef0999c7819ead9798c"><td class="memItemLeft" align="right" valign="top"><a id="ga93b4e739fd61aef0999c7819ead9798c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTDM_TASK_HIGHEST_PRIORITY</b>&#160;&#160;&#160;99</td></tr>
<tr class="separator:ga93b4e739fd61aef0999c7819ead9798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Task Priority Modification</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp482005f3a30d055ef9be299fb2742198"></a><a class="anchor" id="rtdmchangetaskprio"></a>Raise or lower task priorities by one level </p>
</td></tr>
<tr class="memitem:ga74e3f9b76fae80c8fb189b842d683eaa"><td class="memItemLeft" align="right" valign="top"><a id="ga74e3f9b76fae80c8fb189b842d683eaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTDM_TASK_RAISE_PRIORITY</b>&#160;&#160;&#160;(+1)</td></tr>
<tr class="separator:ga74e3f9b76fae80c8fb189b842d683eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee4e374adeb5bac14da349fa7a6527a"><td class="memItemLeft" align="right" valign="top"><a id="ga5ee4e374adeb5bac14da349fa7a6527a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTDM_TASK_LOWER_PRIORITY</b>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:ga5ee4e374adeb5bac14da349fa7a6527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga43315f778f88bdd7415504c6f6d0e0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43315f778f88bdd7415504c6f6d0e0af">&#9670;&nbsp;</a></span>rtdm_task_proc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rtdm_task_proc_t) (void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real-time task procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>argument as passed to <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371" title="Initialise and start a real-time task. ">rtdm_task_init()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa3940cfff7cc72d7bc064a3e279d74ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3940cfff7cc72d7bc064a3e279d74ac">&#9670;&nbsp;</a></span>rtdm_task_busy_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_task_busy_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Busy-wait a specified amount of time. </p>
<p>This service does not schedule out the caller, but rather spins in a tight loop, burning CPU cycles until the timeout elapses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>Delay in nanoseconds. Note that a zero delay does <b>not</b> have the meaning of <code>RTDM_TIMEOUT_INFINITE</code> here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller must not be migratable to different CPUs while executing this service. Otherwise, the actual delay will be undefined.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a id="gaa288d5cf336a98cace8b47eaacb4c629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa288d5cf336a98cace8b47eaacb4c629">&#9670;&nbsp;</a></span>rtdm_task_busy_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_busy_wait </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>spin_ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>sleep_ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe busy waiting. </p>
<p>This service alternates active spinning and sleeping within a wait loop, until a condition is satisfied. While sleeping, a task is scheduled out and does not consume any CPU time.</p>
<p><a class="el" href="group__rtdm__task.html#gaa288d5cf336a98cace8b47eaacb4c629" title="Safe busy waiting. ">rtdm_task_busy_wait()</a> is particularly useful for waiting for a state change reading an I/O register, which usually happens shortly after the wait starts, without incurring the adverse effects of long busy waiting if it doesn't.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The C expression to be tested for detecting completion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spin_ns</td><td>The time to spin on <em>condition</em> before sleeping, expressed as a count of nanoseconds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sleep_ns</td><td>The time to sleep for before spinning again, expressed as a count of nanoseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success if <em>condition</em> is satisfied, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the calling task has been unblocked by a Linux signal or explicitly via <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-EPERM may be returned if an illegal invocation environment is detected.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a id="gafd58b762de7269549d1e54699ceebc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd58b762de7269549d1e54699ceebc0d">&#9670;&nbsp;</a></span>rtdm_task_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtdm_task_t* rtdm_task_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current real-time task. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to task handle</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">mode-unrestricted</a> </dd></dl>

</div>
</div>
<a id="ga7b5581febb2732127736817ca44e86e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b5581febb2732127736817ca44e86e3">&#9670;&nbsp;</a></span>rtdm_task_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_task_destroy </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a real-time task. </p>
<p>This call sends a termination request to <em>task</em>, then waits for it to exit. All RTDM task should check for pending termination requests by calling <a class="el" href="group__rtdm__task.html#ga118ff0961fe05db91c15af5f27bf48dc" title="Check for pending termination request. ">rtdm_task_should_stop()</a> from their work loop.</p>
<p>If <em>task</em> is current, <a class="el" href="group__rtdm__task.html#ga7b5581febb2732127736817ca44e86e3" title="Destroy a real-time task. ">rtdm_task_destroy()</a> terminates the current context, and does not return to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>Task handle as returned by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371" title="Initialise and start a real-time task. ">rtdm_task_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Passing the same task handle to RTDM services after the completion of this function is not allowed.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only, might-switch</a> </dd></dl>

</div>
</div>
<a id="ga44b0701b6c28fa8035711f800fdcd371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b0701b6c28fa8035711f800fdcd371">&#9670;&nbsp;</a></span>rtdm_task_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm__task.html#ga43315f778f88bdd7415504c6f6d0e0af">rtdm_task_proc_t</a>&#160;</td>
          <td class="paramname"><em>task_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise and start a real-time task. </p>
<p>After initialising a task, the task handle remains valid and can be passed to RTDM services until either <a class="el" href="group__rtdm__task.html#ga7b5581febb2732127736817ca44e86e3" title="Destroy a real-time task. ">rtdm_task_destroy()</a> or <a class="el" href="group__rtdm__task.html#ga3a3e4c00605861403c0ea4ec87b31a7b" title="Wait on a real-time task to terminate. ">rtdm_task_join()</a> was invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>Task handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Optional task name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_proc</td><td>Procedure to be executed by the task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Custom argument passed to <code>task_proc()</code> on entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>Priority of the task, see also <a class="el" href="group__rtdm__task.html#rtdmtaskprio">Task Priority Range</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Period in nanoseconds of a cyclic task, 0 for non-cyclic mode. Waiting for the first and subsequent periodic events is done using <a class="el" href="group__rtdm__task.html#ga987d8dcff4e3ec43392d1fe18481639f" title="Wait on next real-time task period. ">rtdm_task_wait_period()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative error code</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only, might-switch</a> </dd></dl>

</div>
</div>
<a id="ga3a3e4c00605861403c0ea4ec87b31a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3e4c00605861403c0ea4ec87b31a7b">&#9670;&nbsp;</a></span>rtdm_task_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_task_join </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a real-time task to terminate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>Task handle as returned by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371" title="Initialise and start a real-time task. ">rtdm_task_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Passing the same task handle to RTDM services after the completion of this function is not allowed.</dd>
<dd>
This service does not trigger the termination of the targeted task. The user has to take of this, otherwise <a class="el" href="group__rtdm__task.html#ga3a3e4c00605861403c0ea4ec87b31a7b" title="Wait on a real-time task to terminate. ">rtdm_task_join()</a> will never return.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">mode-unrestricted</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cobalt__core__thread.html#gac61d70ab94c430e8d96b455221d2fea3">xnthread_join()</a>.</p>

</div>
</div>
<a id="ga4b950475e86d8201cc31724421e0857b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b950475e86d8201cc31724421e0857b">&#9670;&nbsp;</a></span>rtdm_task_set_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_set_period </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a>&#160;</td>
          <td class="paramname"><em>start_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust real-time task period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>Task handle as returned by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371" title="Initialise and start a real-time task. ">rtdm_task_init()</a>, or NULL for referring to the current RTDM task or Cobalt thread.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_date</td><td>The initial (absolute) date of the first release point, expressed in nanoseconds. <em>task</em> will be delayed by the first call to <a class="el" href="group__rtdm__task.html#ga987d8dcff4e3ec43392d1fe18481639f" title="Wait on next real-time task period. ">rtdm_task_wait_period()</a> until this point is reached. If <em>start_date</em> is zero, the first release point is set to <em>period</em> nanoseconds after the current date.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>New period in nanoseconds of a cyclic task, zero to disable cyclic mode for <em>task</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a id="ga286f2d3ff73b3e9c5f24d5a1122a57d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga286f2d3ff73b3e9c5f24d5a1122a57d2">&#9670;&nbsp;</a></span>rtdm_task_set_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_task_set_priority </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust real-time task priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>Task handle as returned by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371" title="Initialise and start a real-time task. ">rtdm_task_init()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>New priority of the task, see also <a class="el" href="group__rtdm__task.html#rtdmtaskprio">Task Priority Range</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a> </dd></dl>

</div>
</div>
<a id="ga118ff0961fe05db91c15af5f27bf48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118ff0961fe05db91c15af5f27bf48dc">&#9670;&nbsp;</a></span>rtdm_task_should_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_should_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for pending termination request. </p>
<p>Check whether a termination request was received by the current RTDM task. Termination requests are sent by calling <a class="el" href="group__rtdm__task.html#ga7b5581febb2732127736817ca44e86e3" title="Destroy a real-time task. ">rtdm_task_destroy()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero indicates that a termination request is pending, in which case the caller should wrap up and exit.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">rtdm-task, might-switch</a> </dd></dl>

</div>
</div>
<a id="gabfae53746165a83a75965b7b0f6710a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfae53746165a83a75965b7b0f6710a0">&#9670;&nbsp;</a></span>rtdm_task_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep a specified amount of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>Delay in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a id="ga1763346568d041f9c66d68224816d15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1763346568d041f9c66d68224816d15b">&#9670;&nbsp;</a></span>rtdm_task_sleep_abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_sleep_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a>&#160;</td>
          <td class="paramname"><em>wakeup_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__rtdm__timer.html#gad0bffecd0182d68967ebb5b47df0bcd0">rtdm_timer_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep until a specified absolute time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeup_time</td><td>Absolute timeout in nanoseconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Selects the timer mode, see RTDM_TIMERMODE_xxx for details</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
<li>-EINVAL is returned if an invalid parameter was passed.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a id="ga741998821c05483db33f17d77c733d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga741998821c05483db33f17d77c733d99">&#9670;&nbsp;</a></span>rtdm_task_sleep_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_sleep_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a>&#160;</td>
          <td class="paramname"><em>wakeup_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep until a specified absolute time. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use rtdm_task_sleep_abs instead!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeup_time</td><td>Absolute timeout in nanoseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a id="gae52cca97ebaf78eec2e31553a4dacd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae52cca97ebaf78eec2e31553a4dacd5e">&#9670;&nbsp;</a></span>rtdm_task_unblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_unblock </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a blocked real-time task. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero is returned if the task was actually unblocked from a pending wait state, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

</div>
</div>
<a id="ga987d8dcff4e3ec43392d1fe18481639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987d8dcff4e3ec43392d1fe18481639f">&#9670;&nbsp;</a></span>rtdm_task_wait_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_task_wait_period </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>overruns_r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on next real-time task period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">overruns_r</td><td>Address of a long word receiving the count of overruns if -ETIMEDOUT is returned, or NULL if the caller don't need that information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if calling task is not in periodic mode.</li>
<li>-ETIMEDOUT is returned if a timer overrun occurred, which indicates that a previous release point has been missed by the calling task.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a id="ga95c0a155cc11c7ef221262c8f9823005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95c0a155cc11c7ef221262c8f9823005">&#9670;&nbsp;</a></span>rtdm_wait_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_wait_complete </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_context *&#160;</td>
          <td class="paramname"><em>wc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark completion for a wait context. </p>
<p>rtdm_complete_wait() marks a wait context as completed, so that <a class="el" href="group__rtdm__task.html#gadc457f5ed51446d25d06f11e9d3b8c47" title="Test completion of a wait context. ">rtdm_wait_is_completed()</a> returns true for such context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wc</td><td>Wait context to complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc457f5ed51446d25d06f11e9d3b8c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc457f5ed51446d25d06f11e9d3b8c47">&#9670;&nbsp;</a></span>rtdm_wait_is_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_wait_is_completed </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_context *&#160;</td>
          <td class="paramname"><em>wc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test completion of a wait context. </p>
<p><a class="el" href="group__rtdm__task.html#gadc457f5ed51446d25d06f11e9d3b8c47" title="Test completion of a wait context. ">rtdm_wait_is_completed()</a> returns true if rtdm_complete_wait() was called for <em>wc</em>. The completion mark is reset each time <a class="el" href="group__rtdm__task.html#ga87dd3ab9abed5417dfcc00f463fd86ec" title="Register wait context. ">rtdm_wait_prepare()</a> is called for a wait context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wc</td><td>Wait context to check for completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero/true if <a class="el" href="group__rtdm__task.html#ga95c0a155cc11c7ef221262c8f9823005" title="Mark completion for a wait context. ">rtdm_wait_complete()</a> was called for <em>wc</em>, zero otherwise. </dd></dl>

</div>
</div>
<a id="ga87dd3ab9abed5417dfcc00f463fd86ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87dd3ab9abed5417dfcc00f463fd86ec">&#9670;&nbsp;</a></span>rtdm_wait_prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_wait_prepare </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_context *&#160;</td>
          <td class="paramname"><em>wc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register wait context. </p>
<p><a class="el" href="group__rtdm__task.html#ga87dd3ab9abed5417dfcc00f463fd86ec" title="Register wait context. ">rtdm_wait_prepare()</a> registers a wait context structure for the caller, which can be later retrieved by a call to rtdm_wait_get_context(). This call is normally issued before the current task blocks on a wait object, waiting for some (producer) code to wake it up. Arbitrary data can be exchanged between both sites via the wait context structure, which is allocated by the waiter (consumer) side.</p>
<p><em>wc</em> is the address of an anchor object which is commonly embedded into a larger structure with arbitrary contents, which needs to be shared between the consumer (waiter) and the producer for implementing the wait code.</p>
<p>A typical implementation pattern for the wait side is:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>rtdm_waitqueue wq;</div><div class="line"><span class="keyword">struct </span>some_wait_context {</div><div class="line">   <span class="keywordtype">int</span> input_value;</div><div class="line">   <span class="keywordtype">int</span> output_value;</div><div class="line">   <span class="keyword">struct </span>rtdm_wait_context wc;</div><div class="line">} wait_context;</div><div class="line"></div><div class="line">wait_context.input_value = 42;</div><div class="line"><a class="code" href="group__rtdm__task.html#ga87dd3ab9abed5417dfcc00f463fd86ec">rtdm_wait_prepare</a>(&amp;wait_context);</div><div class="line">ret = <a class="code" href="group__rtdm__sync.html#ga16d020cefc20213de5929ed2e72fe918">rtdm_wait_condition</a>(&amp;wq, <a class="code" href="group__rtdm__task.html#gadc457f5ed51446d25d06f11e9d3b8c47">rtdm_wait_is_completed</a>(&amp;wait_context));</div><div class="line"><span class="keywordflow">if</span> (ret)</div><div class="line">    <span class="keywordflow">goto</span> wait_failed;</div><div class="line">handle_event(wait_context.output_value);</div></div><!-- fragment --><p>On the producer side, the implementation would look like:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>rtdm_waitqueue wq;</div><div class="line"><span class="keyword">struct </span>some_wait_context {</div><div class="line">   <span class="keywordtype">int</span> input_value;</div><div class="line">   <span class="keywordtype">int</span> output_value;</div><div class="line">   <span class="keyword">struct </span>rtdm_wait_context wc;</div><div class="line">} *wait_context_ptr;</div><div class="line"><span class="keyword">struct </span>rtdm_wait_context *wc;</div><div class="line">rtdm_task_t *task;</div><div class="line"></div><div class="line"><a class="code" href="group__rtdm__sync.html#gaa06735fb5c996f8bc60aff71234f000d">rtdm_for_each_waiter</a>(task, &amp;wq) {</div><div class="line">   wc = rtdm_wait_get_context(task);</div><div class="line">   wait_context_ptr = container_of(wc, <span class="keyword">struct</span> some_wait_context, wc);</div><div class="line">   wait_context_ptr-&gt;output_value = 12;</div><div class="line">}</div><div class="line"><a class="code" href="group__rtdm__sync.html#ga0d9aa704827003402283014c47868d54">rtdm_waitqueue_broadcast</a>(&amp;wq);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wc</td><td>Wait context to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
