<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xenomai: Interrupt management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__core__irq.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interrupt management<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__core.html">Cobalt kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Interrupt management:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__core__irq.png" border="0" alt="" usemap="#group____cobalt____core____irq"/>
<map name="group____cobalt____core____irq" id="group____cobalt____core____irq">
<area shape="rect" id="node2" href="group__cobalt__core.html" title="The Cobalt core is a co&#45;kernel which supplements the Linux kernel for delivering real&#45;time services w..." alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f4d355b8f1e30ac47eb6cdf5b15052a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga2f4d355b8f1e30ac47eb6cdf5b15052a">xnintr_destroy</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:ga2f4d355b8f1e30ac47eb6cdf5b15052a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an interrupt descriptor.  <a href="#ga2f4d355b8f1e30ac47eb6cdf5b15052a">More...</a><br /></td></tr>
<tr class="separator:ga2f4d355b8f1e30ac47eb6cdf5b15052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daaec8f96ae24a57e390c2bb52a7dd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8">xnintr_attach</a> (struct xnintr *intr, void *cookie)</td></tr>
<tr class="memdesc:ga3daaec8f96ae24a57e390c2bb52a7dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach an interrupt descriptor.  <a href="#ga3daaec8f96ae24a57e390c2bb52a7dd8">More...</a><br /></td></tr>
<tr class="separator:ga3daaec8f96ae24a57e390c2bb52a7dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d82d8a287980c1075d70b8e5df6a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga40d82d8a287980c1075d70b8e5df6a77">xnintr_detach</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:ga40d82d8a287980c1075d70b8e5df6a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach an interrupt descriptor.  <a href="#ga40d82d8a287980c1075d70b8e5df6a77">More...</a><br /></td></tr>
<tr class="separator:ga40d82d8a287980c1075d70b8e5df6a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb629c2fda5f3400a86c7139100eebff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#gacb629c2fda5f3400a86c7139100eebff">xnintr_enable</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:gacb629c2fda5f3400a86c7139100eebff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable an interrupt line.  <a href="#gacb629c2fda5f3400a86c7139100eebff">More...</a><br /></td></tr>
<tr class="separator:gacb629c2fda5f3400a86c7139100eebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd483fe4979b3250d2f4ef830ec704ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#gadd483fe4979b3250d2f4ef830ec704ac">xnintr_disable</a> (struct xnintr *intr)</td></tr>
<tr class="memdesc:gadd483fe4979b3250d2f4ef830ec704ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable an interrupt line.  <a href="#gadd483fe4979b3250d2f4ef830ec704ac">More...</a><br /></td></tr>
<tr class="separator:gadd483fe4979b3250d2f4ef830ec704ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f60c3d81107d58d52e3c44d9f8e8a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga1f60c3d81107d58d52e3c44d9f8e8a97">xnintr_affinity</a> (struct xnintr *intr, cpumask_t cpumask)</td></tr>
<tr class="memdesc:ga1f60c3d81107d58d52e3c44d9f8e8a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set processor affinity of interrupt.  <a href="#ga1f60c3d81107d58d52e3c44d9f8e8a97">More...</a><br /></td></tr>
<tr class="separator:ga1f60c3d81107d58d52e3c44d9f8e8a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bcb3882ee1fc8f5580db7f66b2730b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__irq.html#ga2bcb3882ee1fc8f5580db7f66b2730b9">xnintr_init</a> (struct xnintr *intr, const char *name, unsigned int irq, xnisr_t isr, xniack_t iack, int flags)</td></tr>
<tr class="memdesc:ga2bcb3882ee1fc8f5580db7f66b2730b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an interrupt descriptor.  <a href="#ga2bcb3882ee1fc8f5580db7f66b2730b9">More...</a><br /></td></tr>
<tr class="separator:ga2bcb3882ee1fc8f5580db7f66b2730b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1f60c3d81107d58d52e3c44d9f8e8a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f60c3d81107d58d52e3c44d9f8e8a97">&#9670;&nbsp;</a></span>xnintr_affinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_affinity </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpumask_t&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set processor affinity of interrupt. </p>
<p>Restricts the IRQ line associated with the interrupt descriptor <em>intr</em> to be received only on processors which bits are set in <em>cpumask</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of the interrupt descriptor.</td></tr>
    <tr><td class="paramname">cpumask</td><td>The new processor affinity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Depending on architectures, setting more than one bit in <em>cpumask</em> could be meaningless.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a id="ga3daaec8f96ae24a57e390c2bb52a7dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daaec8f96ae24a57e390c2bb52a7dd8">&#9670;&nbsp;</a></span>xnintr_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_attach </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cookie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach an interrupt descriptor. </p>
<p>Attach an interrupt descriptor previously initialized by <a class="el" href="group__cobalt__core__irq.html#ga2bcb3882ee1fc8f5580db7f66b2730b9" title="Initialize an interrupt descriptor. ">xnintr_init()</a>. This operation registers the descriptor at the interrupt pipeline, but does not enable the interrupt line yet. A call to <a class="el" href="group__cobalt__core__irq.html#gacb629c2fda5f3400a86c7139100eebff" title="Enable an interrupt line. ">xnintr_enable()</a> is required to start receiving IRQs from the interrupt line associated to the descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of the interrupt descriptor to attach.</td></tr>
    <tr><td class="paramname">cookie</td><td>A user-defined opaque value which is stored into the descriptor for further retrieval by the interrupt handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if an error occurred while attaching the descriptor.</li>
<li>-EBUSY is returned if the descriptor was already attached.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The caller <b>must not</b> hold nklock when invoking this service, this would cause deadlocks.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attaching an interrupt descriptor resets the tracked number of IRQ receipts to zero. </dd></dl>

</div>
</div>
<a id="ga2f4d355b8f1e30ac47eb6cdf5b15052a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f4d355b8f1e30ac47eb6cdf5b15052a">&#9670;&nbsp;</a></span>xnintr_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_destroy </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an interrupt descriptor. </p>
<p>Destroys an interrupt descriptor previously initialized by <a class="el" href="group__cobalt__core__irq.html#ga2bcb3882ee1fc8f5580db7f66b2730b9" title="Initialize an interrupt descriptor. ">xnintr_init()</a>. The descriptor is automatically detached by a call to <a class="el" href="group__cobalt__core__irq.html#ga40d82d8a287980c1075d70b8e5df6a77" title="Detach an interrupt descriptor. ">xnintr_detach()</a>. No more IRQs will be received through this descriptor after this service has returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of the interrupt descriptor to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p class="reference">References <a class="el" href="group__cobalt__core__irq.html#ga40d82d8a287980c1075d70b8e5df6a77">xnintr_detach()</a>.</p>

</div>
</div>
<a id="ga40d82d8a287980c1075d70b8e5df6a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40d82d8a287980c1075d70b8e5df6a77">&#9670;&nbsp;</a></span>xnintr_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_detach </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach an interrupt descriptor. </p>
<p>This call unregisters an interrupt descriptor previously attached by <a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8" title="Attach an interrupt descriptor. ">xnintr_attach()</a> from the interrupt pipeline. Once detached, the associated interrupt line is disabled, but the descriptor remains valid. The descriptor can be attached anew by a call to <a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8" title="Attach an interrupt descriptor. ">xnintr_attach()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of the interrupt descriptor to detach.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The caller <b>must not</b> hold nklock when invoking this service, this would cause deadlocks.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cobalt__core__irq.html#ga2f4d355b8f1e30ac47eb6cdf5b15052a">xnintr_destroy()</a>.</p>

</div>
</div>
<a id="gadd483fe4979b3250d2f4ef830ec704ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd483fe4979b3250d2f4ef830ec704ac">&#9670;&nbsp;</a></span>xnintr_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_disable </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable an interrupt line. </p>
<p>Disables the interrupt line associated with an interrupt descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of the interrupt descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a id="gacb629c2fda5f3400a86c7139100eebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb629c2fda5f3400a86c7139100eebff">&#9670;&nbsp;</a></span>xnintr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnintr_enable </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable an interrupt line. </p>
<p>Enables the interrupt line associated with an interrupt descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of the interrupt descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a id="ga2bcb3882ee1fc8f5580db7f66b2730b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bcb3882ee1fc8f5580db7f66b2730b9">&#9670;&nbsp;</a></span>xnintr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnintr_init </td>
          <td>(</td>
          <td class="paramtype">struct xnintr *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnisr_t&#160;</td>
          <td class="paramname"><em>isr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xniack_t&#160;</td>
          <td class="paramname"><em>iack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an interrupt descriptor. </p>
<p>When an interrupt occurs on the given <em>irq</em> line, the interrupt service routine <em>isr</em> is fired in order to deal with the hardware event. The interrupt handler may call any non-blocking service from the Cobalt core.</p>
<p>Upon receipt of an IRQ, the interrupt handler <em>isr</em> is immediately called on behalf of the interrupted stack context, the rescheduling procedure is locked, and the interrupt line is masked in the system interrupt controller chip. Upon return, the status of the interrupt handler is checked for the following bits:</p>
<ul>
<li>XN_IRQ_HANDLED indicates that the interrupt request was successfully handled.</li>
<li>XN_IRQ_NONE indicates the opposite to XN_IRQ_HANDLED, meaning that no interrupt source could be identified for the ongoing request by the handler.</li>
</ul>
<p>In addition, one of the following bits may be present in the status:</p>
<ul>
<li>XN_IRQ_DISABLE tells the Cobalt core to disable the interrupt line before returning from the interrupt context.</li>
<li>XN_IRQ_PROPAGATE propagates the IRQ event down the interrupt pipeline to Linux. Using this flag is strongly discouraged, unless you fully understand the implications of such propagation.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The handler should not use these bits if it shares the interrupt line with other handlers in the real-time domain. When any of these bits is detected, the interrupt line is left masked.</dd></dl>
<p>A count of interrupt receipts is tracked into the interrupt descriptor, and reset to zero each time such descriptor is attached. Since this count could wrap around, it should be used as an indication of interrupt activity only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The address of a descriptor the Cobalt core will use to store the interrupt-specific data.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the interrupt or NULL.</td></tr>
    <tr><td class="paramname">irq</td><td>The IRQ line number associated with the interrupt descriptor. This value is architecture-dependent. An interrupt descriptor must be attached to the system by a call to <a class="el" href="group__cobalt__core__irq.html#ga3daaec8f96ae24a57e390c2bb52a7dd8" title="Attach an interrupt descriptor. ">xnintr_attach()</a> before <em>irq</em> events can be received.</td></tr>
    <tr><td class="paramname">isr</td><td>The address of an interrupt handler, which is passed the address of the interrupt descriptor receiving the IRQ.</td></tr>
    <tr><td class="paramname">iack</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the default one. Only very specific situations actually require to override the default setting for this parameter, like having to acknowledge non-standard PIC hardware. <em>iack</em> should return a non-zero value to indicate that the interrupt has been properly acknowledged. If <em>iack</em> is NULL, the default routine will be used instead.</td></tr>
    <tr><td class="paramname">flags</td><td>A set of creation flags affecting the operation. The valid flags are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XN_IRQTYPE_SHARED enables IRQ-sharing with other interrupt objects.</li>
<li>XN_IRQTYPE_EDGE is an additional flag need to be set together with XN_IRQTYPE_SHARED to enable IRQ-sharing of edge-triggered interrupts.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if <em>irq</em> is not a valid interrupt number.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__cobalt__core__timer.html#gae32695b66e4f3f05b2db32f335f88c9d">xntimer_grab_hardware()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
