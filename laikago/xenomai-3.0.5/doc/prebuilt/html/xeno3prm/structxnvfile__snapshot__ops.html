<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xenomai: xnvfile_snapshot_ops Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structxnvfile__snapshot__ops.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">xnvfile_snapshot_ops Struct Reference<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__core.html">Cobalt kernel</a> &raquo; <a class="el" href="group__cobalt__core__vfile.html">Virtual file services</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Snapshot vfile operation descriptor.  
 <a href="structxnvfile__snapshot__ops.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ac5474b3f528be4469315277ad9f91007"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#ac5474b3f528be4469315277ad9f91007">rewind</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)</td></tr>
<tr class="separator:ac5474b3f528be4469315277ad9f91007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22240c5d1975f1d91e94749023684bc"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#af22240c5d1975f1d91e94749023684bc">begin</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)</td></tr>
<tr class="separator:af22240c5d1975f1d91e94749023684bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930d19008b6053e42ef6919cee8a0d95"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#a930d19008b6053e42ef6919cee8a0d95">end</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *buf)</td></tr>
<tr class="separator:a930d19008b6053e42ef6919cee8a0d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d63826b1ec64b2f2feacb56cef4b62"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#a57d63826b1ec64b2f2feacb56cef4b62">next</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)</td></tr>
<tr class="separator:a57d63826b1ec64b2f2feacb56cef4b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29681b4f21a97ecfd1fb0a1e9a79b7a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#ab29681b4f21a97ecfd1fb0a1e9a79b7a">show</a> )(struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)</td></tr>
<tr class="separator:ab29681b4f21a97ecfd1fb0a1e9a79b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7227cb341b314ca9976bdc83528cd7d0"><td class="memItemLeft" align="right" valign="top">ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html#a7227cb341b314ca9976bdc83528cd7d0">store</a> )(struct xnvfile_input *input)</td></tr>
<tr class="separator:a7227cb341b314ca9976bdc83528cd7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Snapshot vfile operation descriptor. </p>
<p><a class="anchor" id="snapshot_ops"></a> This structure describes the operations available with a snapshot-driven vfile. It defines handlers for returning a printable snapshot of some Xenomai object contents upon a user-space read request, and for updating this object upon a user-space write request. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="af22240c5d1975f1d91e94749023684bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22240c5d1975f1d91e94749023684bc">&#9670;&nbsp;</a></span>begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* xnvfile_snapshot_ops::begin) (struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="snapshot_begin"></a>This handler should allocate the snapshot buffer to hold records during the data collection phase. When specified, all records collected via the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next()</a>handler" will be written to a cell from the memory area returned by <a class="el" href="structxnvfile__snapshot__ops.html#af22240c5d1975f1d91e94749023684bc">begin()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current snapshot iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the record buffer, if the call succeeds. Otherwise:</dd></dl>
<ul>
<li>NULL in case of allocation error. This will abort the data collection, and return -ENOMEM to the reader.</li>
<li>VFILE_SEQ_EMPTY, a special value indicating that no record will be output. In such a case, the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> will not be called, and the data collection will stop immediately. However, the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_show">show() handler</a> will still be called once, with a NULL data pointer (i.e. header display request).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This handler is optional; if none is given, an internal allocation depending on the value returned by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_rewind">rewind() handler</a> can be obtained. </dd></dl>

</div>
</div>
<a id="a930d19008b6053e42ef6919cee8a0d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930d19008b6053e42ef6919cee8a0d95">&#9670;&nbsp;</a></span>end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* xnvfile_snapshot_ops::end) (struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *buf)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="snapshot_end"></a>This handler releases the memory buffer previously obtained from <a class="el" href="structxnvfile__snapshot__ops.html#af22240c5d1975f1d91e94749023684bc">begin()</a>. It is usually called after the snapshot data has been output by <a class="el" href="structxnvfile__snapshot__ops.html#ab29681b4f21a97ecfd1fb0a1e9a79b7a">show()</a>, but it may also be called before rewinding the vfile after a revision change, to release the dropped buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current snapshot iterator.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to the buffer to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine is optional and the pointer may be NULL. It is not needed upon internal buffer allocation; see the description of the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_rewind">rewind()</a>handler". </dd></dl>

</div>
</div>
<a id="a57d63826b1ec64b2f2feacb56cef4b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d63826b1ec64b2f2feacb56cef4b62">&#9670;&nbsp;</a></span>next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* xnvfile_snapshot_ops::next) (struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="snapshot_next"></a>This handler fetches the next record, as part of the snapshot data to be sent back to the reader via the <a class="el" href="structxnvfile__snapshot__ops.html#ab29681b4f21a97ecfd1fb0a1e9a79b7a">show()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current snapshot iterator.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the record to fill in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a strictly positive value, if the call succeeds and leaves a valid record into <em>data</em>, which should be passed to the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_show">show() handler()</a> during the formatting and output phase. Otherwise:</dd></dl>
<ul>
<li>A negative error code. This will abort the data collection, and return this status to the reader.</li>
<li>VFILE_SEQ_SKIP, a special value indicating that the current record should be skipped. In such a case, the <em>data</em> pointer is not advanced to the next position before the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> is called anew.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This handler is called with the vfile lock held. Before each invocation of this handler, the vfile core checks whether the revision tag has been touched, in which case the data collection is restarted from scratch. A data collection phase succeeds whenever all records can be fetched via the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a>, while the revision tag remains unchanged, which indicates that a consistent snapshot of the object state was taken. </dd></dl>

</div>
</div>
<a id="ac5474b3f528be4469315277ad9f91007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5474b3f528be4469315277ad9f91007">&#9670;&nbsp;</a></span>rewind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* xnvfile_snapshot_ops::rewind) (struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="snapshot_rewind"></a>This handler (re-)initializes the data collection, moving the seek pointer at the first record. When the file revision tag is touched while collecting data, the current reading is aborted, all collected data dropped, and the vfile is eventually rewound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current snapshot iterator. Two useful information can be retrieved from this iterator in this context:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>it-&gt;vfile is a pointer to the descriptor of the virtual file being rewound.</li>
<li>xnvfile_iterator_priv(it) returns a pointer to the private data area, available from the descriptor, which size is vfile-&gt;privsz. If the latter size is zero, the returned pointer is meaningless and should not be used.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A negative error code aborts the data collection, and is passed back to the reader. Otherwise:</dd></dl>
<ul>
<li>a strictly positive value is interpreted as the total number of records which will be returned by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> during the data collection phase. If no <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_begin">begin() handler</a> is provided in the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>, this value is used to allocate the snapshot buffer internally. The size of this buffer would then be vfile-&gt;datasz * value.</li>
<li>zero leaves the allocation to the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_begin">begin() handler</a> if present, or indicates that no record is to be output in case such handler is not given.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This handler is optional; a NULL value indicates that nothing needs to be done for rewinding the vfile. It is called with the vfile lock held. </dd></dl>

</div>
</div>
<a id="ab29681b4f21a97ecfd1fb0a1e9a79b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29681b4f21a97ecfd1fb0a1e9a79b7a">&#9670;&nbsp;</a></span>show</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* xnvfile_snapshot_ops::show) (struct <a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a> *it, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="snapshot_show"></a>This handler should format and output a record from the collected data.</p>
<p>xnvfile_printf(), xnvfile_write(), xnvfile_puts() and xnvfile_putc() are available to format and/or emit the output. All routines take the iterator argument <em>it</em> as their first parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current snapshot iterator.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the record to format then output. The first call to the handler is always passed a NULL <em>data</em> pointer; the show handler should test this special value to output any header that fits, prior to receiving more calls with actual records.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the call succeeds, also indicating that the handler should be called for the next record if any. Otherwise:</dd></dl>
<ul>
<li>A negative error code. This will abort the output phase, and return this status to the reader.</li>
<li>VFILE_SEQ_SKIP, a special value indicating that the current record should be skipped and will not be output. </li>
</ul>

</div>
</div>
<a id="a7227cb341b314ca9976bdc83528cd7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7227cb341b314ca9976bdc83528cd7d0">&#9670;&nbsp;</a></span>store</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* xnvfile_snapshot_ops::store) (struct xnvfile_input *input)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="snapshot_store"></a>This handler receives data written to the vfile, likely for updating the associated Xenomai object's state, or triggering any other action which fits. This is the only handler which deals with the write-side of a vfile. It is called when writing to the /proc entry of the vfile from a user-space process.</p>
<p>The input data is described by a descriptor passed to the handler, which may be subsequently passed to parsing helper routines. For instance, <a class="el" href="group__cobalt__core__vfile.html#gae45ea5410707367c9e032dc36fc30916" title="Read in a C-string written to the vfile. ">xnvfile_get_string()</a> will accept the input descriptor for returning the written data as a null-terminated character string. On the other hand, <a class="el" href="group__cobalt__core__vfile.html#ga18746b2aae928c0281ae57ef47086600" title="Evaluate the string written to the vfile as a long integer. ">xnvfile_get_integer()</a> will attempt to return a long integer from the input data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A pointer to an input descriptor. It refers to an opaque data from the handler's standpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read from the input descriptor if the call succeeds. Otherwise, a negative error code. Return values from parsing helper routines are commonly passed back to the caller by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">store() handler</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This handler is optional, and may be omitted for read-only vfiles. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/cobalt/kernel/<a class="el" href="vfile_8h_source.html">vfile.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structxnvfile__snapshot__ops.html">xnvfile_snapshot_ops</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
