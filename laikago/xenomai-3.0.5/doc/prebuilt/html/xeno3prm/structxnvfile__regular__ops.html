<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xenomai: xnvfile_regular_ops Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structxnvfile__regular__ops.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">xnvfile_regular_ops Struct Reference<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__core.html">Cobalt kernel</a> &raquo; <a class="el" href="group__cobalt__core__vfile.html">Virtual file services</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Regular vfile operation descriptor.  
 <a href="structxnvfile__regular__ops.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:acaaff5be06437a0bb6f10c729460b867"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#acaaff5be06437a0bb6f10c729460b867">rewind</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr class="separator:acaaff5be06437a0bb6f10c729460b867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38cc11ce487fb953b7132f451ead19d"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#aa38cc11ce487fb953b7132f451ead19d">begin</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr class="separator:aa38cc11ce487fb953b7132f451ead19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a079d41711ba0be6adb3e0e14d3a9a"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#a68a079d41711ba0be6adb3e0e14d3a9a">next</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr class="separator:a68a079d41711ba0be6adb3e0e14d3a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1a13a4087586cbce3ea236ef28682e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#a7c1a13a4087586cbce3ea236ef28682e">end</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr class="separator:a7c1a13a4087586cbce3ea236ef28682e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7de5409ed1b0a4cdc6b26b2b4d76eb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#a9d7de5409ed1b0a4cdc6b26b2b4d76eb">show</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it, void *data)</td></tr>
<tr class="separator:a9d7de5409ed1b0a4cdc6b26b2b4d76eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b20dc8b361d70f479b9aa2b72b9583"><td class="memItemLeft" align="right" valign="top">ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#ac9b20dc8b361d70f479b9aa2b72b9583">store</a> )(struct xnvfile_input *input)</td></tr>
<tr class="separator:ac9b20dc8b361d70f479b9aa2b72b9583"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Regular vfile operation descriptor. </p>
<p><a class="anchor" id="regular_ops"></a> This structure describes the operations available with a regular vfile. It defines handlers for sending back formatted kernel data upon a user-space read request, and for obtaining user data upon a user-space write request. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="aa38cc11ce487fb953b7132f451ead19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38cc11ce487fb953b7132f451ead19d">&#9670;&nbsp;</a></span>begin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* xnvfile_regular_ops::begin) (struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="regular_begin"></a>This handler should prepare for iterating over the records upon a read request, starting from the specified position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current vfile iterator. On entry, it-&gt;pos is set to the (0-based) position of the first record to output. This handler may be called multiple times with different position requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first record to format and output, to be passed to the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler</a> as its <em>data</em> parameter, if the call succeeds. Otherwise:</dd></dl>
<ul>
<li>NULL in case no record is available, in which case the read operation will terminate immediately with no output.</li>
<li>VFILE_SEQ_START, a special value indicating that <a class="el" href="structxnvfile__regular__ops.html#regular_show">the show() handler</a> should receive a NULL data pointer first, in order to output a header.</li>
<li>ERR_PTR(errno), where errno is a negative error code; upon error, the current operation will be aborted immediately.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This handler is optional; if none is given in the operation descriptor (i.e. NULL value), the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler()</a> will be called only once for a read operation, with a NULL <em>data</em> parameter. This particular setting is convenient for simple regular vfiles having a single, fixed record to output. </dd></dl>

</div>
</div>
<a id="a7c1a13a4087586cbce3ea236ef28682e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1a13a4087586cbce3ea236ef28682e">&#9670;&nbsp;</a></span>end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* xnvfile_regular_ops::end) (struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="regular_end"></a>This handler is called after all records have been output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current vfile iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This handler is optional and the pointer may be NULL. </dd></dl>

</div>
</div>
<a id="a68a079d41711ba0be6adb3e0e14d3a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a079d41711ba0be6adb3e0e14d3a9a">&#9670;&nbsp;</a></span>next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* xnvfile_regular_ops::next) (struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="regular_next"></a>This handler should return the address of the next record to format and output by the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show()</a>handler".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current vfile iterator. On entry, it-&gt;pos is set to the (0-based) position of the next record to output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the next record to format and output, to be passed to the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler</a> as its <em>data</em> parameter, if the call succeeds. Otherwise:</dd></dl>
<ul>
<li>NULL in case no record is available, in which case the read operation will terminate immediately with no output.</li>
<li>ERR_PTR(errno), where errno is a negative error code; upon error, the current operation will be aborted immediately.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This handler is optional; if none is given in the operation descriptor (i.e. NULL value), the read operation will stop after the first invocation of the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler</a>. </dd></dl>

</div>
</div>
<a id="acaaff5be06437a0bb6f10c729460b867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaff5be06437a0bb6f10c729460b867">&#9670;&nbsp;</a></span>rewind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* xnvfile_regular_ops::rewind) (struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="regular_rewind"></a>This handler is called only once, when the virtual file is opened, before the <a class="el" href="structxnvfile__regular__ops.html#regular_begin">begin() handler</a> is invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the vfile iterator which will be used to read the file contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero should be returned upon success. Otherwise, a negative error code aborts the operation, and is passed back to the reader.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This handler is optional. It should not be used to allocate resources but rather to perform consistency checks, since no closure call is issued in case the open sequence eventually fails. </dd></dl>

</div>
</div>
<a id="a9d7de5409ed1b0a4cdc6b26b2b4d76eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7de5409ed1b0a4cdc6b26b2b4d76eb">&#9670;&nbsp;</a></span>show</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* xnvfile_regular_ops::show) (struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="regular_show"></a>This handler should format and output a record.</p>
<p>xnvfile_printf(), xnvfile_write(), xnvfile_puts() and xnvfile_putc() are available to format and/or emit the output. All routines take the iterator argument <em>it</em> as their first parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A pointer to the current vfile iterator.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the record to format then output. The first call to the handler may receive a NULL <em>data</em> pointer, depending on the presence and/or return of a <a class="el" href="structxnvfile__regular__ops.html#regular_begin">hander</a>; the show handler should test this special value to output any header that fits, prior to receiving more calls with actual records.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the call succeeds, also indicating that the handler should be called for the next record if any. Otherwise:</dd></dl>
<ul>
<li>A negative error code. This will abort the output phase, and return this status to the reader.</li>
<li>VFILE_SEQ_SKIP, a special value indicating that the current record should be skipped and will not be output. </li>
</ul>

</div>
</div>
<a id="ac9b20dc8b361d70f479b9aa2b72b9583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b20dc8b361d70f479b9aa2b72b9583">&#9670;&nbsp;</a></span>store</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* xnvfile_regular_ops::store) (struct xnvfile_input *input)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="regular_store"></a>This handler receives data written to the vfile, likely for updating some kernel setting, or triggering any other action which fits. This is the only handler which deals with the write-side of a vfile. It is called when writing to the /proc entry of the vfile from a user-space process.</p>
<p>The input data is described by a descriptor passed to the handler, which may be subsequently passed to parsing helper routines. For instance, <a class="el" href="group__cobalt__core__vfile.html#gae45ea5410707367c9e032dc36fc30916" title="Read in a C-string written to the vfile. ">xnvfile_get_string()</a> will accept the input descriptor for returning the written data as a null-terminated character string. On the other hand, <a class="el" href="group__cobalt__core__vfile.html#ga18746b2aae928c0281ae57ef47086600" title="Evaluate the string written to the vfile as a long integer. ">xnvfile_get_integer()</a> will attempt to return a long integer from the input data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A pointer to an input descriptor. It refers to an opaque data from the handler's standpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read from the input descriptor if the call succeeds. Otherwise, a negative error code. Return values from parsing helper routines are commonly passed back to the caller by the <a class="el" href="structxnvfile__regular__ops.html#regular_store">store() handler</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This handler is optional, and may be omitted for read-only vfiles. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/cobalt/kernel/<a class="el" href="vfile_8h_source.html">vfile.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structxnvfile__regular__ops.html">xnvfile_regular_ops</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
