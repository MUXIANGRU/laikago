<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xenomai: Smokey API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__smokey.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Smokey API</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple infrastructure for writing and running smoke tests.  
<a href="#details">More...</a></p>
<p>A simple infrastructure for writing and running smoke tests. </p>
<p>Smokey is based on the Copperplate API, therefore is available over the single and dual kernel Xenomai configurations indifferently.</p>
<p>The API provides a set of services for declaring any number of test plugins, embodied into a test program. Each plugin usually implements a single smoke test, checking a particular feature of interest. Each plugin present in the running executable is automatically detected by the Smokey init routine. In addition, the Smokey API parses all arguments and options passed on the command line to the executable, running pre-defined actions which are therefore automatically recognized by all programs linked against the Smokey library.</p>
<dl class="section user"><dt>Writing smoke tests with Smokey</dt><dd></dd></dl>
<p>A smoke test is composed of a routine which implements the test code, and a set of runtime settings/attributes for running such code. The routine prototype shall be:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> run_&lt;test_name&gt;(<span class="keyword">struct </span>smokey_test *t, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *<span class="keyword">const</span> argv[])</div></div><!-- fragment --><p>The test routine should return a zero value for success, or any negated POSIX error code for indicating the failure to the test driver (e.g. -EINVAL if some value is found to be wrong).</p>
<p>With <em>t</em> referring to the Smokey test descriptor, and <em>argc</em>, <em>argv</em> the argument count and vector expunged from all the inner options which may have been previously interpreted by the Smokey API and inner layers (such as Copperplate).</p>
<p>The Smokey API provides the services to declare a complete test (named <b>foo</b> in this example) as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;smokey/smokey.h&gt;</span></div><div class="line"></div><div class="line">smokey_test_plugin(foo, <span class="comment">// test name</span></div><div class="line">                   SMOKEY_ARGLIST( <span class="comment">// argument list</span></div><div class="line">                        SMOKEY_INT(some_integer),</div><div class="line">                        SMOKEY_STRING(some_string),</div><div class="line">                        SMOKEY_BOOL(some_boolean),</div><div class="line">              ),</div><div class="line">                   <span class="comment">// description</span></div><div class="line">              <span class="stringliteral">&quot;A dummy Smokey-based test plugin\n&quot;</span></div><div class="line">              <span class="stringliteral">&quot;\taccepting three optional arguments:\n&quot;</span></div><div class="line">              <span class="stringliteral">&quot;\tsome_integer=&lt;value&gt;\n&quot;</span></div><div class="line">              <span class="stringliteral">&quot;\tsome_string=&lt;string&gt;\n&quot;</span></div><div class="line">              <span class="stringliteral">&quot;\tsome_bool[=0/1]\n&quot;</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> run_foo(<span class="keyword">struct</span> smokey_test *t, <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *<span class="keyword">const</span> argv[])</div><div class="line">{</div><div class="line">     <span class="keywordtype">int</span> i_arg = 0, nargs;</div><div class="line">     <span class="keywordtype">char</span> *s_arg = NULL;</div><div class="line">     <span class="keywordtype">bool</span> b_arg = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        nargs = smokey_parse_args(t, argc, argv);</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span> (SMOKEY_ARG_ISSET(foo, some_integer))</div><div class="line">        i_arg = SMOKEY_ARG_INT(foo, some_integer);</div><div class="line">     <span class="keywordflow">if</span> (SMOKEY_ARG_ISSET(foo, some_string))</div><div class="line">        s_arg = SMOKEY_ARG_STRING(foo, some_string);</div><div class="line">     <span class="keywordflow">if</span> (SMOKEY_ARG_ISSET(foo, some_boolean))</div><div class="line">        b_arg = SMOKEY_ARG_INT(foo, some_boolean);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> run_some_hypothetical_smoke_test_code(i_arg, s_arg, b_arg);</div><div class="line">}</div></div><!-- fragment --><p>As illustrated, a smoke test is at least composed of a test plugin descriptor (i.e. <em>smokey_test_plugin()</em>), and a run handler named after the test.</p>
<dl class="section user"><dt>Test arguments</dt><dd></dd></dl>
<p>Smokey recognizes three argument declarators, namely: SMOKEY_INT(name) for a C (signed) integer, SMOKEY_BOOL(name) for a boolean value and SMOKEY_STRING(name) for a character string.</p>
<p>Each argument can be passed to the test code as a name=value pair, where <em>name</em> should match one of the declarators. Before the test-specific arguments can be accessed, a call to smokey_parse_args() must be issued by the test code, passing the parameters received in the run handler. This routine returns the number of arguments found on the command line matching the an entry in SMOKEY_ARGLIST().</p>
<p>Once smokey_parse_args() has returned with a non-zero value, each argument can be checked individually for presence. If a valid argument was matched on the command line, SMOKEY_ARG_ISSET(test_name, arg_name) returns non-zero. In the latter case, its value can be retrieved by a similar call to SMOKEY_ARG_INT(test_name, arg_name), SMOKEY_ARG_STRING(test_name, arg_name) or SMOKEY_ARG_BOOL(test_name, arg_name).</p>
<p>In the above example, passing "some_integer=3" on the command line of any program implementing such Smokey-based test would cause the variable i_arg to receive "3" as a value.</p>
<dl class="section user"><dt>Pre-defined Smokey options</dt><dd></dd></dl>
<p>Any program linked against the Smokey API implicitly recognizes the following options:</p>
<ul>
<li>&ndash;list dumps the list of tests implemented in the program to stdout. The information given includes the description strings provided in the plugin declarators (smokey_test_plugin()). The position and symbolic name of each test is also issued, which may be used in id specifications with the &ndash;run option (see below).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Test positions may vary depending on changes to the host program like adding or removing other tests, the symbolic name however is stable and identifies each test uniquely.</dd></dl>
<ul>
<li><p class="startli">&ndash;run[=&lt;id[,id...]&gt;] selects the tests to be run, determining the active test list among the overall set of tests detected in the host program. The test driver code (e.g. implementing a test harness program on top of Smokey) may then iterate over the <em>smokey_test_list</em> for accessing each active test individually, in the enumeration order specified by the user (Use for_each_smokey_test() for that).</p>
<p class="startli">If no argument is passed to &ndash;run, Smokey assumes that all tests detected in the current program should be picked, filling <em>smokey_test_list</em> with tests by increasing position order.</p>
<p class="startli">Otherwise, id may be a test position, a symbolic name, or a range thereof delimited by a dash character. A symbolic name may be matched using a glob(3) type regular expression.</p>
<p class="startli">id specification may be:</p><ul>
<li>0-9, picks tests #0 to #9</li>
<li>-3, picks tests #0 to #3</li>
<li>5-, picks tests #5 to the highest possible test position</li>
<li>2-0, picks tests #2 to #0, in decreasing order</li>
<li>foo, picks test foo only</li>
<li>0,1,foo- picks tests #0, #1, and any test from foo up to the last test defined</li>
<li>fo* picks any test with a name starting by "fo"</li>
</ul>
</li>
<li>&ndash;exclude=&lt;id[,id...]&gt; excludes the given tests from the test list. The format of the argument is identical to the one accepted by the &ndash;run option.</li>
<li>&ndash;keep-going sets the boolean flag <em>smokey_keep_going</em> to a non-zero value, indicating to the test driver that receiving a failure code from a smoke test should not abort the test loop. This flag is not otherwise interpreted by the Smokey API.</li>
<li>&ndash;verbose[=level] sets the integer <em>smokey_verbose_mode</em> to a non-zero value, which should be interpreted by all parties as the desired verbosity level (defaults to 1).</li>
<li>&ndash;vm gives a hint to the test code, about running in a virtual environment, such as KVM. When passed, the boolean <em>smokey_on_vm</em> is set. Each test may act upon this setting, such as skipping time-dependent checks that may fail due to any slowdown induced by the virtualization.</li>
</ul>
<dl class="section user"><dt>Writing a test driver based on the Smokey API</dt><dd></dd></dl>
<p>A test driver provides the main() entry point, which should iterate over the test list (<em>smokey_test_list</em>) prepared by the Smokey API, for running each test individually. The <em>for_each_smokey_test()</em> helper is available for iterating over the active test list.</p>
<p>When this entry point is called, all the initialization chores, including the test detection and the active test selection have been performed by the Smokey API already.</p>
<dl class="section user"><dt>Issuing information notices</dt><dd></dd></dl>
<p>The printf-like <em>smokey_note()</em> routine is available for issuing notices to the output device (currently stdout), unless &ndash;silent was detected on the command line. smokey_note() outputs a terminating newline character. Notes are enabled for any verbosity level greater than zero.</p>
<dl class="section user"><dt>Issuing trace messages</dt><dd></dd></dl>
<p>The printf-like <em>smokey_trace()</em> routine is available for issuing progress messages to the output device (currently stdout), unless &ndash;silent was detected on the command line. smokey_trace() outputs a terminating newline character. Traces are enabled for any verbosity level greater than one.</p>
<p>Therefore, a possible implementation of a test driver could be as basic as:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;error.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;smokey/smokey.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *<span class="keyword">const</span> argv[])</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>smokey_test *t;</div><div class="line">    <span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (pvlist_empty(&amp;smokey_test_list))</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">     for_each_smokey_test(t) {</div><div class="line">        ret = t-&gt;run(t, argc, argv);</div><div class="line">        <span class="keywordflow">if</span> (ret) {</div><div class="line">                <span class="keywordflow">if</span> (smokey_keep_going)</div><div class="line">                        <span class="keywordflow">continue</span>;</div><div class="line">                error(1, -ret, <span class="stringliteral">&quot;test %s failed&quot;</span>, t-&gt;name);</div><div class="line">        }</div><div class="line">        smokey_note(<span class="stringliteral">&quot;%s OK&quot;</span>, t-&gt;name);</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
