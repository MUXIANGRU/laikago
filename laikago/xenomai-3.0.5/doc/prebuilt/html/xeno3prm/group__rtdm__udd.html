<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Xenomai: User-space driver core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__rtdm__udd.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">User-space driver core<div class="ingroups"><a class="el" href="group__rtdm.html">RTDM</a> &raquo; <a class="el" href="group__rtdm__profiles.html">Device Profiles</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This profile includes all mini-drivers sitting on top of the User-space Device Driver framework (UDD).  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for User-space driver core:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtdm__udd.png" border="0" alt="" usemap="#group____rtdm____udd"/>
<map name="group____rtdm____udd" id="group____rtdm____udd">
<area shape="rect" id="node1" href="group__rtdm__profiles.html" title="Pre&#45;defined classes of real&#45;time devices. " alt="" coords="5,5,116,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudd__memregion.html">udd_memregion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudd__device.html">udd_device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudd__signotify.html">udd_signotify</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UDD event notification descriptor.  <a href="structudd__signotify.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa5bee7471396c7b182a5a2a5fb60d230"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#gaa5bee7471396c7b182a5a2a5fb60d230">udd_register_device</a> (struct <a class="el" href="structudd__device.html">udd_device</a> *udd)</td></tr>
<tr class="memdesc:gaa5bee7471396c7b182a5a2a5fb60d230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a UDD device.  <a href="#gaa5bee7471396c7b182a5a2a5fb60d230">More...</a><br /></td></tr>
<tr class="separator:gaa5bee7471396c7b182a5a2a5fb60d230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389544ffa49f17fe3417d97122ed3acb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga389544ffa49f17fe3417d97122ed3acb">udd_unregister_device</a> (struct <a class="el" href="structudd__device.html">udd_device</a> *udd)</td></tr>
<tr class="memdesc:ga389544ffa49f17fe3417d97122ed3acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a UDD device.  <a href="#ga389544ffa49f17fe3417d97122ed3acb">More...</a><br /></td></tr>
<tr class="separator:ga389544ffa49f17fe3417d97122ed3acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306a8671bd96a1ea578c5f76e646ef67"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structudd__device.html">udd_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga306a8671bd96a1ea578c5f76e646ef67">udd_get_device</a> (struct rtdm_fd *fd)</td></tr>
<tr class="memdesc:ga306a8671bd96a1ea578c5f76e646ef67"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTDM file descriptor to target UDD device.  <a href="#ga306a8671bd96a1ea578c5f76e646ef67">More...</a><br /></td></tr>
<tr class="separator:ga306a8671bd96a1ea578c5f76e646ef67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd19086f467b6ba791690a565d2c509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga7bd19086f467b6ba791690a565d2c509">udd_notify_event</a> (struct <a class="el" href="structudd__device.html">udd_device</a> *udd)</td></tr>
<tr class="memdesc:ga7bd19086f467b6ba791690a565d2c509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify an IRQ event for an unmanaged interrupt.  <a href="#ga7bd19086f467b6ba791690a565d2c509">More...</a><br /></td></tr>
<tr class="separator:ga7bd19086f467b6ba791690a565d2c509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ee451ee6e96cbb88254877ca5dd5d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga7ee451ee6e96cbb88254877ca5dd5d3f">udd_enable_irq</a> (struct <a class="el" href="structudd__device.html">udd_device</a> *udd, rtdm_event_t *done)</td></tr>
<tr class="memdesc:ga7ee451ee6e96cbb88254877ca5dd5d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the device IRQ line.  <a href="#ga7ee451ee6e96cbb88254877ca5dd5d3f">More...</a><br /></td></tr>
<tr class="separator:ga7ee451ee6e96cbb88254877ca5dd5d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa15680426042c8c411b6fcf10627da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#gaafa15680426042c8c411b6fcf10627da">udd_disable_irq</a> (struct <a class="el" href="structudd__device.html">udd_device</a> *udd, rtdm_event_t *done)</td></tr>
<tr class="memdesc:gaafa15680426042c8c411b6fcf10627da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the device IRQ line.  <a href="#gaafa15680426042c8c411b6fcf10627da">More...</a><br /></td></tr>
<tr class="separator:gaafa15680426042c8c411b6fcf10627da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a9780334448cdbb66d147c845806ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#gaa3a9780334448cdbb66d147c845806ff">UDD_IRQ_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaa3a9780334448cdbb66d147c845806ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">No IRQ managed.  <a href="#gaa3a9780334448cdbb66d147c845806ff">More...</a><br /></td></tr>
<tr class="separator:gaa3a9780334448cdbb66d147c845806ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d95e2dc3d3bf9de65c0c36889668d39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga2d95e2dc3d3bf9de65c0c36889668d39">UDD_IRQ_CUSTOM</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:ga2d95e2dc3d3bf9de65c0c36889668d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ directly managed from the mini-driver on top of the UDD core.  <a href="#ga2d95e2dc3d3bf9de65c0c36889668d39">More...</a><br /></td></tr>
<tr class="separator:ga2d95e2dc3d3bf9de65c0c36889668d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Memory types for mapping</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp71d615dea0df3c3b41308094d593d780"></a><a class="anchor" id="udd_memory_types"></a>Types of memory for mapping</p>
<p>The UDD core implements a default -&gt;mmap() handler which first attempts to hand over the request to the corresponding handler defined by the mini-driver. If not present, the UDD core establishes the mapping automatically, depending on the memory type defined for the region. </p>
</td></tr>
<tr class="memitem:ga3d99c468cad10f370079e51db1223755"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga3d99c468cad10f370079e51db1223755">UDD_MEM_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga3d99c468cad10f370079e51db1223755"><td class="mdescLeft">&#160;</td><td class="mdescRight">No memory region.  <a href="#ga3d99c468cad10f370079e51db1223755">More...</a><br /></td></tr>
<tr class="separator:ga3d99c468cad10f370079e51db1223755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00632ad4aad373171da9fc6b7d44275e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga00632ad4aad373171da9fc6b7d44275e">UDD_MEM_PHYS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga00632ad4aad373171da9fc6b7d44275e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical I/O memory region.  <a href="#ga00632ad4aad373171da9fc6b7d44275e">More...</a><br /></td></tr>
<tr class="separator:ga00632ad4aad373171da9fc6b7d44275e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55c896372f69102bab1ae98e7117a2f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#gaa55c896372f69102bab1ae98e7117a2f">UDD_MEM_LOGICAL</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gaa55c896372f69102bab1ae98e7117a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel logical memory region (e.g.  <a href="#gaa55c896372f69102bab1ae98e7117a2f">More...</a><br /></td></tr>
<tr class="separator:gaa55c896372f69102bab1ae98e7117a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35860acaa182b11fa9caaf3b80912393"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga35860acaa182b11fa9caaf3b80912393">UDD_MEM_VIRTUAL</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga35860acaa182b11fa9caaf3b80912393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual memory region with no direct physical mapping (e.g.  <a href="#ga35860acaa182b11fa9caaf3b80912393">More...</a><br /></td></tr>
<tr class="separator:ga35860acaa182b11fa9caaf3b80912393"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
UDD_IOCTL</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp75e7d40a733f9d4d63b67cd6e4139735"></a><a class="anchor" id="udd_ioctl_codes"></a>IOCTL requests </p>
</td></tr>
<tr class="memitem:ga3262c2cf44554d882cfe1fbcb8c5c06d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga3262c2cf44554d882cfe1fbcb8c5c06d">UDD_RTIOC_IRQEN</a>&#160;&#160;&#160;_IO(RTDM_CLASS_UDD, 0)</td></tr>
<tr class="memdesc:ga3262c2cf44554d882cfe1fbcb8c5c06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the interrupt line.  <a href="#ga3262c2cf44554d882cfe1fbcb8c5c06d">More...</a><br /></td></tr>
<tr class="separator:ga3262c2cf44554d882cfe1fbcb8c5c06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e774aed523fce77d75ac2ba24e9aebc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#ga5e774aed523fce77d75ac2ba24e9aebc">UDD_RTIOC_IRQDIS</a>&#160;&#160;&#160;_IO(RTDM_CLASS_UDD, 1)</td></tr>
<tr class="memdesc:ga5e774aed523fce77d75ac2ba24e9aebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the interrupt line.  <a href="#ga5e774aed523fce77d75ac2ba24e9aebc">More...</a><br /></td></tr>
<tr class="separator:ga5e774aed523fce77d75ac2ba24e9aebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad418ff50a125079ee342be1089adc081"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__udd.html#gad418ff50a125079ee342be1089adc081">UDD_RTIOC_IRQSIG</a>&#160;&#160;&#160;_IOW(RTDM_CLASS_UDD, 2, struct <a class="el" href="structudd__signotify.html">udd_signotify</a>)</td></tr>
<tr class="memdesc:gad418ff50a125079ee342be1089adc081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable signal notification upon interrupt event.  <a href="#gad418ff50a125079ee342be1089adc081">More...</a><br /></td></tr>
<tr class="separator:gad418ff50a125079ee342be1089adc081"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This profile includes all mini-drivers sitting on top of the User-space Device Driver framework (UDD). </p>
<p>The generic UDD core driver enables interrupt control and I/O memory access interfaces to user-space device drivers, as defined by the mini-drivers when registering.</p>
<p>A mini-driver supplements the UDD core with ancillary functions for dealing with <a class="el" href="structudd__memregion.html#udd_memory_region">memory mappings</a> and <a class="el" href="structudd__device.html#udd_irq_handler">interrupt control</a> for a particular I/O card/device.</p>
<p>UDD-compliant mini-drivers only have to provide the basic support for dealing with the interrupt sources present in the device, so that most part of the device requests can be handled from a Xenomai application running in user-space. Typically, a mini-driver would handle the interrupt top-half, and the user-space application would handle the bottom-half.</p>
<p>This profile is reminiscent of the UIO framework available with the Linux kernel, adapted to the dual kernel Cobalt environment. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2d95e2dc3d3bf9de65c0c36889668d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d95e2dc3d3bf9de65c0c36889668d39">&#9670;&nbsp;</a></span>UDD_IRQ_CUSTOM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_IRQ_CUSTOM&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IRQ directly managed from the mini-driver on top of the UDD core. </p>
<p>The mini-driver is in charge of attaching the handler(s) to the IRQ(s) it manages, notifying the Cobalt threads waiting for IRQ events by calling the <a class="el" href="group__rtdm__udd.html#ga7bd19086f467b6ba791690a565d2c509" title="Notify an IRQ event for an unmanaged interrupt. ">udd_notify_event()</a> service. </p>

<p class="reference">Referenced by <a class="el" href="group__rtdm__udd.html#gaafa15680426042c8c411b6fcf10627da">udd_disable_irq()</a>, <a class="el" href="group__rtdm__udd.html#ga7ee451ee6e96cbb88254877ca5dd5d3f">udd_enable_irq()</a>, <a class="el" href="group__rtdm__udd.html#gaa5bee7471396c7b182a5a2a5fb60d230">udd_register_device()</a>, and <a class="el" href="group__rtdm__udd.html#ga389544ffa49f17fe3417d97122ed3acb">udd_unregister_device()</a>.</p>

</div>
</div>
<a id="gaa3a9780334448cdbb66d147c845806ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3a9780334448cdbb66d147c845806ff">&#9670;&nbsp;</a></span>UDD_IRQ_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_IRQ_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No IRQ managed. </p>
<p><a class="anchor" id="udd_irq_special"></a>Special IRQ values for <a class="el" href="structudd__device.html#aab89d90525c1e515756a87116c8adf09" title="IRQ number. ">udd_device.irq</a> Passing this code implicitly disables all interrupt-related services, including control (disable/enable) and notification. </p>

<p class="reference">Referenced by <a class="el" href="group__rtdm__udd.html#gaafa15680426042c8c411b6fcf10627da">udd_disable_irq()</a>, <a class="el" href="group__rtdm__udd.html#ga7ee451ee6e96cbb88254877ca5dd5d3f">udd_enable_irq()</a>, <a class="el" href="group__rtdm__udd.html#gaa5bee7471396c7b182a5a2a5fb60d230">udd_register_device()</a>, and <a class="el" href="group__rtdm__udd.html#ga389544ffa49f17fe3417d97122ed3acb">udd_unregister_device()</a>.</p>

</div>
</div>
<a id="gaa55c896372f69102bab1ae98e7117a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55c896372f69102bab1ae98e7117a2f">&#9670;&nbsp;</a></span>UDD_MEM_LOGICAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_MEM_LOGICAL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kernel logical memory region (e.g. </p>
<p>kmalloc()). By default, the UDD core maps such memory to a virtual user range by calling the <a class="el" href="group__rtdm__util.html#ga3aee69f7a5fa8c0e2302c8b159b1915a" title="Map a kernel logical memory range to a virtual user area. ">rtdm_mmap_kmem()</a> service. </p>

</div>
</div>
<a id="ga3d99c468cad10f370079e51db1223755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d99c468cad10f370079e51db1223755">&#9670;&nbsp;</a></span>UDD_MEM_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_MEM_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No memory region. </p>
<p>Use this type code to disable an entry in the array of memory mappings, i.e. <a class="el" href="structudd__device.html#a07a8a1d85f094c147a600e2c3b7f5995" title="Array of memory regions defined by the device. ">udd_device.mem_regions</a>[]. </p>

</div>
</div>
<a id="ga00632ad4aad373171da9fc6b7d44275e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00632ad4aad373171da9fc6b7d44275e">&#9670;&nbsp;</a></span>UDD_MEM_PHYS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_MEM_PHYS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical I/O memory region. </p>
<p>By default, the UDD core maps such memory to a virtual user range by calling the <a class="el" href="group__rtdm__util.html#gab5b1c69962cac7abf2db3ee04e1cc06b" title="Map an I/O memory range to a virtual user area. ">rtdm_mmap_iomem()</a> service. </p>

</div>
</div>
<a id="ga35860acaa182b11fa9caaf3b80912393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35860acaa182b11fa9caaf3b80912393">&#9670;&nbsp;</a></span>UDD_MEM_VIRTUAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_MEM_VIRTUAL&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual memory region with no direct physical mapping (e.g. </p>
<p>vmalloc()). By default, the UDD core maps such memory to a virtual user range by calling the <a class="el" href="group__rtdm__util.html#gacaad8fa06fc8607fc44bcc6314afeda1" title="Map a virtual memory range to a virtual user area. ">rtdm_mmap_vmem()</a> service. </p>

</div>
</div>
<a id="ga5e774aed523fce77d75ac2ba24e9aebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e774aed523fce77d75ac2ba24e9aebc">&#9670;&nbsp;</a></span>UDD_RTIOC_IRQDIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_RTIOC_IRQDIS&#160;&#160;&#160;_IO(RTDM_CLASS_UDD, 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the interrupt line. </p>
<p>The UDD-class mini-driver should handle this request when received through its -&gt;ioctl() handler if provided. Otherwise, the UDD core disables the interrupt line in the interrupt controller before returning to the caller.</p>
<dl class="section note"><dt>Note</dt><dd>The mini-driver must handle the UDD_RTIOC_IRQEN request for a custom IRQ from its -&gt;ioctl() handler, otherwise such request receives -EIO from the UDD core. </dd></dl>

</div>
</div>
<a id="ga3262c2cf44554d882cfe1fbcb8c5c06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3262c2cf44554d882cfe1fbcb8c5c06d">&#9670;&nbsp;</a></span>UDD_RTIOC_IRQEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_RTIOC_IRQEN&#160;&#160;&#160;_IO(RTDM_CLASS_UDD, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the interrupt line. </p>
<p>The UDD-class mini-driver should handle this request when received through its -&gt;ioctl() handler if provided. Otherwise, the UDD core enables the interrupt line in the interrupt controller before returning to the caller. </p>

</div>
</div>
<a id="gad418ff50a125079ee342be1089adc081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad418ff50a125079ee342be1089adc081">&#9670;&nbsp;</a></span>UDD_RTIOC_IRQSIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDD_RTIOC_IRQSIG&#160;&#160;&#160;_IOW(RTDM_CLASS_UDD, 2, struct <a class="el" href="structudd__signotify.html">udd_signotify</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable signal notification upon interrupt event. </p>
<p>A valid <a class="el" href="structudd__signotify.html#udd_signotify">notification descriptor</a> must be passed along with this request, which is handled by the UDD core directly.</p>
<dl class="section note"><dt>Note</dt><dd>The mini-driver must handle the UDD_RTIOC_IRQDIS request for a custom IRQ from its -&gt;ioctl() handler, otherwise such request receives -EIO from the UDD core. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaafa15680426042c8c411b6fcf10627da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa15680426042c8c411b6fcf10627da">&#9670;&nbsp;</a></span>udd_disable_irq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_disable_irq </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudd__device.html">udd_device</a> *&#160;</td>
          <td class="paramname"><em>udd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the device IRQ line. </p>
<p>This service issues a request to the regular kernel for disabling the IRQ line registered by the driver. If the caller runs in primary mode, the request is scheduled but deferred until the current CPU leaves the real-time domain (see note). Otherwise, the request is immediately handled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udd</td><td>The UDD driver handling the IRQ to disable. If no IRQ was registered by the driver at the UDD core, this routine has no effect.</td></tr>
    <tr><td class="paramname">done</td><td>Optional event to signal upon completion. If non-NULL, <em>done</em> will be posted by a call to <a class="el" href="group__rtdm__sync__event.html#ga1217402b82034b26fe25c26f1e5b32c9" title="Signal an event occurrence. ">rtdm_event_signal()</a> after the interrupt line is disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The deferral is required as some interrupt management code involved in disabling interrupt lines may not be safely executed from primary mode. By passing a valid <em>done</em> object address, the caller can wait for the request to complete, by sleeping on <a class="el" href="group__rtdm__sync__event.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence. ">rtdm_event_wait()</a>. </dd></dl>

<p class="reference">References <a class="el" href="structudd__device.html#aab89d90525c1e515756a87116c8adf09">udd_device::irq</a>, <a class="el" href="group__rtdm__udd.html#ga2d95e2dc3d3bf9de65c0c36889668d39">UDD_IRQ_CUSTOM</a>, and <a class="el" href="group__rtdm__udd.html#gaa3a9780334448cdbb66d147c845806ff">UDD_IRQ_NONE</a>.</p>

</div>
</div>
<a id="ga7ee451ee6e96cbb88254877ca5dd5d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ee451ee6e96cbb88254877ca5dd5d3f">&#9670;&nbsp;</a></span>udd_enable_irq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_enable_irq </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudd__device.html">udd_device</a> *&#160;</td>
          <td class="paramname"><em>udd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_event_t *&#160;</td>
          <td class="paramname"><em>done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the device IRQ line. </p>
<p>This service issues a request to the regular kernel for enabling the IRQ line registered by the driver. If the caller runs in primary mode, the request is scheduled but deferred until the current CPU leaves the real-time domain (see note). Otherwise, the request is immediately handled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udd</td><td>The UDD driver handling the IRQ to disable. If no IRQ was registered by the driver at the UDD core, this routine has no effect.</td></tr>
    <tr><td class="paramname">done</td><td>Optional event to signal upon completion. If non-NULL, <em>done</em> will be posted by a call to <a class="el" href="group__rtdm__sync__event.html#ga1217402b82034b26fe25c26f1e5b32c9" title="Signal an event occurrence. ">rtdm_event_signal()</a> after the interrupt line is enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The deferral is required as some interrupt management code involved in enabling interrupt lines may not be safely executed from primary mode. By passing a valid <em>done</em> object address, the caller can wait for the request to complete, by sleeping on <a class="el" href="group__rtdm__sync__event.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence. ">rtdm_event_wait()</a>. </dd></dl>

<p class="reference">References <a class="el" href="structudd__device.html#aab89d90525c1e515756a87116c8adf09">udd_device::irq</a>, <a class="el" href="group__rtdm__udd.html#ga2d95e2dc3d3bf9de65c0c36889668d39">UDD_IRQ_CUSTOM</a>, and <a class="el" href="group__rtdm__udd.html#gaa3a9780334448cdbb66d147c845806ff">UDD_IRQ_NONE</a>.</p>

</div>
</div>
<a id="ga306a8671bd96a1ea578c5f76e646ef67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga306a8671bd96a1ea578c5f76e646ef67">&#9670;&nbsp;</a></span>udd_get_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structudd__device.html">udd_device</a>* udd_get_device </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RTDM file descriptor to target UDD device. </p>
<p>Retrieves the UDD device from a RTDM file descriptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor received by an ancillary I/O handler from a mini-driver based on the UDD core.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the UDD device to which <em>fd</em> refers to.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This service is intended for use by mini-drivers based on the UDD core exclusively. Passing file descriptors referring to other RTDM devices will certainly lead to invalid results.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">mode-unrestricted</a> </dd></dl>

<p class="reference">References <a class="el" href="structrtdm__device.html#a61c4d79a727f060a968d37abc852b6c2">rtdm_device::driver</a>, <a class="el" href="structrtdm__driver.html#af770015d22a50ce86d5ab57bb563d9cc">rtdm_driver::profile_info</a>, and <a class="el" href="driver_8h.html#ab0378feca734478fb704060e216e65db">rtdm_fd_device()</a>.</p>

</div>
</div>
<a id="ga7bd19086f467b6ba791690a565d2c509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd19086f467b6ba791690a565d2c509">&#9670;&nbsp;</a></span>udd_notify_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_notify_event </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudd__device.html">udd_device</a> *&#160;</td>
          <td class="paramname"><em>udd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify an IRQ event for an unmanaged interrupt. </p>
<p>When the UDD core shall hand over the interrupt management for a device to the mini-driver (see UDD_IRQ_CUSTOM), the latter should notify the UDD core when IRQ events are received by calling this service.</p>
<p>As a result, the UDD core wakes up any Cobalt thread waiting for interrupts on the device via a read(2) or select(2) call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udd</td><td>UDD device descriptor receiving the IRQ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">coreirq-only</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>In case the <a class="el" href="structudd__device.html#udd_irq_handler">IRQ handler</a> from the mini-driver requested the UDD core not to re-enable the interrupt line, the application may later request the unmasking by issuing the UDD_RTIOC_IRQEN ioctl(2) command. Writing a non-zero integer to the device via the write(2) system call has the same effect. </dd></dl>

<p class="reference">References <a class="el" href="group__rtdm__sync__event.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal()</a>, <a class="el" href="group__rtdm__irq.html#gab34c102e3e8af1f27786b2996247913d">rtdm_irq_disable()</a>, and <a class="el" href="group__rtdm__irq.html#ga231362e861125cfdcbe5b4137fc70680">rtdm_irq_enable()</a>.</p>

</div>
</div>
<a id="gaa5bee7471396c7b182a5a2a5fb60d230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5bee7471396c7b182a5a2a5fb60d230">&#9670;&nbsp;</a></span>udd_register_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int udd_register_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudd__device.html">udd_device</a> *&#160;</td>
          <td class="paramname"><em>udd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a UDD device. </p>
<p>This routine registers a mini-driver at the UDD core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udd</td><td><a class="el" href="structudd__device.html#udd_device">UDD device descriptor</a> which should describe the new device properties.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success, otherwise a negative error code is received, from the set of error codes defined by <a class="el" href="group__rtdm__device__register.html#ga40005c775b8c1f0f1077ce6e50120cd2" title="Register a RTDM device. ">rtdm_dev_register()</a>. In addition, the following error codes can be returned:</dd></dl>
<ul>
<li>-EINVAL, some of the memory regions declared in the <a class="el" href="structudd__device.html#a07a8a1d85f094c147a600e2c3b7f5995" title="Array of memory regions defined by the device. ">udd_device.mem_regions</a>[] array have invalid properties, i.e. bad type, NULL name, zero length or address. Any undeclared region entry from the array must bear the UDD_MEM_NONE type.</li>
<li>-EINVAL, if <a class="el" href="structudd__device.html#aab89d90525c1e515756a87116c8adf09" title="IRQ number. ">udd_device.irq</a> is different from UDD_IRQ_CUSTOM and UDD_IRQ_NONE but invalid, causing <a class="el" href="group__rtdm__irq.html#ga9bb3d95218ac5261e4033fb0bf695073" title="Register an interrupt handler. ">rtdm_irq_request()</a> to fail.</li>
<li>-EINVAL, if <a class="el" href="structudd__device.html#acc143e9af9f5a1a6de12a09730370e4c" title="Additional device flags (e.g. ">udd_device.device_flags</a> contains invalid flags.</li>
<li>-ENXIO can be received if this service is called while the Cobalt kernel is disabled.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p class="reference">References <a class="el" href="structudd__device.html#acc143e9af9f5a1a6de12a09730370e4c">udd_device::device_flags</a>, <a class="el" href="structudd__device.html#aa6001084a7f2eb10225ce5c9369999c1">udd_device::interrupt</a>, <a class="el" href="structudd__device.html#aab89d90525c1e515756a87116c8adf09">udd_device::irq</a>, <a class="el" href="group__rtdm__device__register.html#ga43ced044106ae9c1f5500d0041307d8f">RTDM_PROTOCOL_DEVICE</a>, <a class="el" href="group__rtdm__udd.html#ga2d95e2dc3d3bf9de65c0c36889668d39">UDD_IRQ_CUSTOM</a>, and <a class="el" href="group__rtdm__udd.html#gaa3a9780334448cdbb66d147c845806ff">UDD_IRQ_NONE</a>.</p>

</div>
</div>
<a id="ga389544ffa49f17fe3417d97122ed3acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga389544ffa49f17fe3417d97122ed3acb">&#9670;&nbsp;</a></span>udd_unregister_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int udd_unregister_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structudd__device.html">udd_device</a> *&#160;</td>
          <td class="paramname"><em>udd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a UDD device. </p>
<p>This routine unregisters a mini-driver from the UDD core. This routine waits until all connections to <em>udd</em> have been closed prior to unregistering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">udd</td><td>UDD device descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success, otherwise -ENXIO is received if this service is called while the Cobalt kernel is disabled.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p class="reference">References <a class="el" href="structudd__device.html#aab89d90525c1e515756a87116c8adf09">udd_device::irq</a>, <a class="el" href="group__rtdm__sync__event.html#ga7b27d0206027a07958d4a09017e8a3fe">rtdm_event_destroy()</a>, <a class="el" href="group__rtdm__irq.html#gaf246c0d9fa42a18afbeabd3e3c087c8e">rtdm_irq_free()</a>, <a class="el" href="group__rtdm__udd.html#ga2d95e2dc3d3bf9de65c0c36889668d39">UDD_IRQ_CUSTOM</a>, and <a class="el" href="group__rtdm__udd.html#gaa3a9780334448cdbb66d147c845806ff">UDD_IRQ_NONE</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
